<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 内存泄露问题实践 | Jichao's Tech Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-84228722-2','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 内存泄露问题实践</h1><a id="logo" href="/.">Jichao's Tech Notes</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 内存泄露问题实践</h1><div class="post-meta">Jul 19, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>这篇文章将会涉及下面几个方面:</p>
<ol>
<li>几个循环引用的例子, 均是从项目中直接拿出来的实际例子.</li>
<li>可能引起内存问题的情况总结.<br>不但会谈到什么情况下会有循环引用的问题,  还会谈到什么情况下不会发生循环引用的问题.<br>不但会谈到什么时候weak-strong dance有用, 还会谈到什么时候weak-strong dance没用.  </li>
<li>如何在<strong>开发过程中</strong>实时发现内存泄露问题.</li>
<li>如何在<strong>开发完成后</strong>找出内存泄露问题.</li>
</ol>
<h2 id="1-几个循环引用的例子"><a href="#1-几个循环引用的例子" class="headerlink" title="1. 几个循环引用的例子"></a>1. 几个循环引用的例子</h2><h3 id="1-一个隐蔽的循环引用"><a href="#1-一个隐蔽的循环引用" class="headerlink" title="1) 一个隐蔽的循环引用"></a>1) 一个隐蔽的循环引用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.viewModel.loadDataCommand</span><br><span class="line">                    keyPath:<span class="string">@"result"</span></span><br><span class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      block:^(<span class="keyword">id</span> observer, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *change) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    CommandResult *result = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">    <span class="keyword">if</span> (result.error) &#123;</span><br><span class="line">        [<span class="keyword">super</span> loadDataFailure:result.error];</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        _headerView.segmentIndex = <span class="keyword">self</span>.jumptonew ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        _navBarVC.barImageEntity = <span class="keyword">self</span>.viewModel.shopHeadEntity.topbarImg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="2-另一个隐蔽的循环引用"><a href="#2-另一个隐蔽的循环引用" class="headerlink" title="2) 另一个隐蔽的循环引用"></a>2) 另一个隐蔽的循环引用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (MGJLiveRankUserView *v <span class="keyword">in</span> <span class="keyword">self</span>.userViews) &#123;</span><br><span class="line">    [<span class="keyword">self</span> addSubview:v];</span><br><span class="line">    @weakify(<span class="keyword">self</span>);</span><br><span class="line">    [v bk_whenTapped:^&#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(liveRankView:didTapUser:)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate liveRankView:<span class="keyword">self</span> didTapUser:v.userEntity.userId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-FBKVOController的坑"><a href="#3-FBKVOController的坑" class="headerlink" title="3) FBKVOController的坑"></a>3) FBKVOController的坑</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span></span><br><span class="line">                    keyPath:<span class="string">@"emojiViewStatus"</span></span><br><span class="line">                    options:<span class="number">0</span></span><br><span class="line">                      block:^(<span class="keyword">id</span> observer, <span class="keyword">id</span> object, <span class="built_in">NSDictionary</span> *change) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> dealEmojiViewWithEmojiStatus:object];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="4-某个ScanCodeViewController的dealloc方法"><a href="#4-某个ScanCodeViewController的dealloc方法" class="headerlink" title="4) 某个ScanCodeViewController的dealloc方法"></a>4) 某个ScanCodeViewController的dealloc方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> stopScaning];</span><br><span class="line">    [_timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-没有循环引用-但仍有问题"><a href="#5-没有循环引用-但仍有问题" class="headerlink" title="5) 没有循环引用, 但仍有问题"></a>5) 没有循环引用, 但仍有问题</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(i * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> doSomething];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dealloc"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案:"></a>答案:</h3><p>1.直接访问实例变量(<code>_headerView</code>和<code>_navBarVC</code>), 导致<code>weak-strong dance</code>无效, 最终导致循环引用.<br>另外<code>[super loadDataFailure:result.error]</code>里面的<code>super</code>也会造成循环引用, </p>
<blockquote>
<p>objc中super是编译器标示符，并不像self一样是一个对象，遇到向super发的方法时会转译成objc_msgSendSuper(…)，而参数中的对象还是self，于是从父类开始沿继承链寻找- class这个方法，最后在NSObject中找到（若无override），此时，[self class]和[super class]已经等价了。 引自<a href="http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/" target="_blank" rel="noopener">iOS 程序员 6 级考试</a></p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/bmiddle/72f96cbagw1f5qdns2ea2j20go06q3yu.jpg" alt="图示">  </p>
<p>解决办法:<br>问题1: 将 super 改为 self<br>问题2: 坚持使用self来访问实例变量. (使用<code>self.headerView</code>或<code>self-&gt;_headerView</code>)   </p>
<p>2.注意<code>[self.delegate liveRankView:self didTapUser:v.userEntity.userId]</code>里面的<code>v</code>, <code>v -&gt; tap_block -&gt; v</code> 导致循环引用.<br>这个就比较坑了, 当时用MLeaksFinder检测出来这个有泄漏, 我看只有一行代码, 不太可能有问题啊, 是不是误报了? 后来给dealloc下断点, 发现死活调不到, 被活活打脸.<br><img src="http://ww2.sinaimg.cn/bmiddle/72f96cbagw1f5qdnu9x26j20gk076q38.jpg" alt="图示"><br>解决办法: weakify(v)或者用一个临时变量保存v.userEntity.userId, 然后传这个临时变量进block.</p>
<p>3.KVOController中, <code>observer</code> <code>observee</code>都是<code>self</code>.<br>KVOController会retain observee, 造成 所以形成 <code>self(observer) -&gt; self.KVOController -&gt; self(observee)</code> 的循环引用, 详细可参考这个<a href="https://github.com/facebook/KVOController/issues/48" target="_blank" rel="noopener">issue</a>. 只要 observee 反过来强引用 observer 就会造成循环引用, weak-strong dance都没用, 本例中是它的一种特殊情况(observee 就是 observer).<br><img src="http://ww4.sinaimg.cn/bmiddle/72f96cbagw1f5qdnvlfawj20mi0a4q3p.jpg" alt="图示"><br>解决办法: 使用KVOController里的self.KVOControllerNonRetaining, 他不会retain observee, 或者使用 BlocksKit里的 <code>- (NSString *)bk_addObserverForKeyPath:(NSString *)keyPath task:(void (^)(id target))task;</code></p>
<p>4.这个是由于timer使用不当, <code>self -&gt; self.timer -&gt; self</code> 循环引用, 也就是说dealloc永远调用不到. 在dealloc释放timer的操作永远执行不到.<br><img src="http://ww1.sinaimg.cn/bmiddle/72f96cbagw1f5qdnwzjnbj20gg06qwes.jpg" alt="图示"><br>解决办法: 手工打破循环, 在viewWillDisapear时调用timer的invalidate方法, 或者使用 GCD Timer, <a href="https://github.com/mindsnacks/MSWeakTimer" target="_blank" rel="noopener">MSWeakTimer</a>.  </p>
<p>5.这个不是循环引用, 但是会造成VC在1000s后才释放, 属于<code>延迟释放</code>问题.<br>虽然一般不会用dispatch_after delay 1000s, 但是在复杂的业务场景中, 可能存在复杂的dispatch_after嵌套等情况.<br>解决办法: weakify(self), 然后如果self已经释放, 就直接return. </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(i * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> doSomething];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="2-可能引起内存问题的情况总结"><a href="#2-可能引起内存问题的情况总结" class="headerlink" title="2. 可能引起内存问题的情况总结"></a>2. 可能引起内存问题的情况总结</h2><h3 id="1-weak-strong-dance-和-block"><a href="#1-weak-strong-dance-和-block" class="headerlink" title="1) weak-strong dance 和 block"></a>1) weak-strong dance 和 block</h3><h4 id="weak-strong-dance使用情况的分析"><a href="#weak-strong-dance使用情况的分析" class="headerlink" title="weak-strong dance使用情况的分析:"></a><code>weak-strong dance</code>使用情况的分析:</h4><p>一般来说 weak-strong dance 可以避免大部分循环引用问题, 但是也不能盲目的使用.<br>简单介绍下weak-strong dance, 老司机可以跳过.<br>原始的写法是:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;   </span><br><span class="line">__<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>__weak</code>打破了循环引用, 在self释放时, weakSelf自动置空, 至于为什么又用<code>__strong</code>的原因是为了防止block中的代码执行一半, self释放了, weakself也就是nil了. block中代码执行一半就半途而废了.<br>后来我们引入libextobjc中的 @weakify 和 @strongfiy 来简写. 其原理还是一样的.  </p>
<p>需要注意的是, 在嵌套的blocks中, 只需@weakify(self)一次, 但必须在每个blocks里都@strongify(self), 可以参考这个<a href="https://github.com/jspahrsummers/libextobjc/issues/45" target="_blank" rel="noopener">issue</a>.</p>
<p>前面说<code>weak-strong dance</code>并不是万能的, 我们从block的使用来具体分析一下.</p>
<h4 id="block的使用可以分成三种-1"><a href="#block的使用可以分成三种-1" class="headerlink" title="block的使用可以分成三种: [1]"></a>block的使用可以分成三种: [1]</h4><p><strong>1 临时性的，只用在栈当中，不会存储起来</strong><br>比如数组的<code>enumerateObjectsUsingBlock</code>方法<br>比如masonry的<code>mas_makeConstraints</code>直接执行block, 不曾持有block<br>在这些情况下, 不需要<code>weak-strong dance</code>.<br>下图可以看到mas_makeConstraints实现就是拿了block直接用, 没有持有<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2 需要存储起来，但只会调用一次，或者有一个完成时期</strong><br>比如一个 UIView 的动画, 动画完成之后, 需要使用 block 通知外面, 一旦调用 block 之后, 这个 block 就可以释放了.<br>再比如网络库的successBlock, 它会在网络请求结束释放该block.<br>再比如GCD的相关方法, 排队执行完就释放该block.   </p>
<p>在这些情况下, 有时需要<code>weak-strong dance</code><br>比如网络超时设为30s, 那个有可能网络库在30s后再会释放block里的对象. 造成资源的浪费. 这时候就需要<code>weak-strong dance</code>.  再比如例子5也需要<code>weak-strong dance</code>.<br>比如UIView的动画, 0.3s后动画完成, 0s延迟, 就不需要<code>weak-strong dance</code>.   </p>
<p><strong>3 需要存储起来，可能会调用多次</strong><br>比如按钮的点击事件，假如采用 block 实现，这种 block 就需要长期存储，并且会调用多次。调用之后，block 也不可以删除，可能还有下一次按钮的点击。   </p>
<p>在这些情况下, 都需要<code>weak-strong dance</code>. 并且有可能还不够, 比如例子1和例子2   </p>
<h4 id="2-delegate-用-strong-修饰"><a href="#2-delegate-用-strong-修饰" class="headerlink" title="2) delegate 用 strong 修饰"></a>2) delegate 用 strong 修饰</h4><p>虽然最最低级的错误, 几乎不会有人再犯了,   </p>
<h4 id="3-Toll-Free-Bridging"><a href="#3-Toll-Free-Bridging" class="headerlink" title="3) Toll-Free Bridging"></a>3) Toll-Free Bridging</h4><p>在CF对象和NS对象之间转换时, 我们会使用<code>__bridge</code>来桥接, 除了<code>__bridge_transfer</code>会将CF对象交给ARC管理, <code>__bridge</code>和<code>__bridge_retained</code>都需要手工管理CF对象.<br>具体可以参考Mika Ash老师的<a href="https://mikeash.com/pyblog/friday-qa-2011-09-30-automatic-reference-counting.html" target="_blank" rel="noopener">这篇文章</a>.   </p>
<h4 id="4-可能造成延迟释放的情况"><a href="#4-可能造成延迟释放的情况" class="headerlink" title="4) 可能造成延迟释放的情况"></a>4) 可能造成延迟释放的情况</h4><ul>
<li>dispatch_after:1000s<br>解决办法: block里面使用weakself, 判断weakself为空就return</li>
<li>[self performSelector:@selector(method1:) withObject:nil afterDelay:1000];<br>解决办法: 在dealloc中调用[NSObject cancelPreviousPerformRequestsWithTarget:self]</li>
<li>NSOperationQueue<br>解决办法: 在dealloc中调用[queue cancelAllOperations]</li>
</ul>
<p>block和performSelector等的使用一定要考虑到对象的生命周期，block等会延长对象的生命，延迟释放，由此可能会造成逻辑上时序的问题.</p>
<h3 id="5-NSNotificationCenter"><a href="#5-NSNotificationCenter" class="headerlink" title="5) NSNotificationCenter"></a>5) NSNotificationCenter</h3><p>需要注意的是 <code>NSNotificationCenter</code> 需要 removeObserver 不是由于循环引用的问题,<br>通知中心维护的是观察者是unsafe_unretained 引用, 类似于assgin, 不是weak, 不会自动置空, 使用unsafe_unretained的原因是兼容老版本的iOS系统, 所以要及时removeObserver, 否则可能造成访问野指针crash.  </p>
<p>另外, 在VC中使用<code>addObserverForName:object:queue:usingBlock:</code>后, 在dealloc中调用<code>[[NSNotificationCenter defaultCenter] removeObserver:self];</code>是无效的, 原因是<code>addObserverForName:object:queue:usingBlock:</code>的observer不再是self了, 而是<code>id observer = addObserverForName:object:queue:usingBlock:</code>中的observer. 所以正确移除的办法是保留observer的引用然后移除. 在具体的使用中, <code>weak-strong dance</code>之后, 并不会造成VC的无法释放, 只会造成observer空跑, 影响不是很大.   </p>
<h3 id="6-WeakProxy"><a href="#6-WeakProxy" class="headerlink" title="6) WeakProxy"></a>6) WeakProxy</h3><p><code>NSTimer</code> 或者 <code>[self mgj_observe:self forKeyPath:xxx]</code>等这些会强引用observer的API, 在dealloc中去释放是没有用的, 在上面例子4已经提到了.<br>还有一种方法解决这个问题, 就是<code>WeakProxy</code>, FLAnimatedImage里面有一个实现, 用法是:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLWeakProxy *weakProxy = [FLWeakProxy weakProxyForObject:<span class="keyword">self</span>];</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">.01</span> target:weakProxy selector:<span class="keyword">@selector</span>(scanAnimation) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure></p>
<p>FLWeakProxy 只持有self的weak引用, 并通过OC的消息转发机制将消息转发给self处理, 这样timer就不会强引用self, dealloc里的<code>[self.timer invalidate]</code>就可以得到调用.</p>
<h2 id="3-使用MLeakFinder在开发过程中实时发现内存泄露问题"><a href="#3-使用MLeakFinder在开发过程中实时发现内存泄露问题" class="headerlink" title="3. 使用MLeakFinder在开发过程中实时发现内存泄露问题"></a>3. 使用MLeakFinder在开发过程中实时发现内存泄露问题</h2><p>在我们的项目中是引入<a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="noopener">MLeakFinder</a>第三方库, 原理是当一个 UIViewController 被 pop 时, 理论上该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放, 我们在 3s 后去 ping 这些对象, 如果这些对象还在就触发警告, 提醒开发者最近的改动引入了内存泄露. 详细的原理见<a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="noopener">这里</a></p>
<p>在我们的实践中, MLeakFinder已经成功发现了项目中多处内存泄露, 并且在开发中也多次监控到新的代码改动造成的内存泄露.<br>需要注意的是, MLeakFinder只默认在3s后去ping UIViewController和UIView, 其他的Object不在这个范围内, <strong>需要手工监控, 使用MLCheck(self.otherObject)这个方法添加监控的对象</strong>.<br>理论上可以用runtime去拿到VC里用strong修饰的property, 然后加到MLCheck里, 不过这些property里面可能有单例需要排除一下.<br>另外MLeakFinder只是预警, 详细的泄露之处需要自行排查. 不过在开发过程中, 只要检查新引入的改动即可.<br>根据<a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="noopener">这篇介绍</a> MLeaksFinder2通过追踪对象的生命周期解决了延迟释放误报的问题, 在对象dealloc后, 关闭之前的警告的alert.<br>MLeaksFinder2还引入了<a href="https://github.com/facebook/FBRetainCycleDetector" target="_blank" rel="noopener">FBRetainCycleDetector</a>, 当发现嫌疑对象时, 使用FBRetainCycleDetector来找出真相. 不过在具体的测试过程中, 由于FBRetainCycleDetector问题, 查明真相并不是那么好用.</p>
<h2 id="4-使用Instruments排查现有项目的内存问题"><a href="#4-使用Instruments排查现有项目的内存问题" class="headerlink" title="4. 使用Instruments排查现有项目的内存问题."></a>4. 使用Instruments排查现有项目的内存问题.</h2><p>Instruments Leak有两种办法, 一个是<code>Auto Snapshot</code>, 一个是<code>Mark Generation</code><br>实践中, 使用<code>Auto Snapshot</code>并没有太多的收获, 只看到一个个红叉, 找不到具体的泄露, 可能是姿势不对…<br><img src="http://ww3.sinaimg.cn/large/72f96cbagw1f5qdo44jjlj216a092dhn.jpg" alt="用auto snapshot只看到一个个红叉, 看泄露列表都是些无关的对象"><br>所以我主要详细介绍<code>Mark Generation</code> .<br><code>Mark Generation</code>的原理: 代追踪(Generation Tracking)是指在两次标记之间拍摄所有仍然活着的对象的快照. 当我们有一个重复的任务, 我们认为可能会内存泄露的时候, Generation Tracking是很有用的, 例如, 导航View Controller的进出.<br>具体的方法是手工在push VC前点<code>Mark Generation</code>一下, 然后pop VC后再点<code>Mark Generation</code>一次, 对比两代之间多出来的对象, 逐一核查, 找到泄露的对象.<br><img src="http://ww2.sinaimg.cn/large/72f96cbagw1f5qdo60yquj21kw0jgq84.jpg" alt="Mark Generation按钮的位置"><br><img src="http://ww3.sinaimg.cn/mw1024/72f96cbagw1f5qdo71z9fj213e0qejxu.jpg" alt="pushVC是得到GenerationB A, pop后得到 GenerationBB, 排查GenerationB"><br><strong>注意</strong><br>instruments 打要开 dSYM 生成, 否则看不到具体的函数名<br><img src="http://ww2.sinaimg.cn/large/72f96cbagw1f5qdo8nnmej20te030jry.jpg" alt="打要开 dSYM 生成"></p>
<p>详细使用过程可参考这两个链接 <a href="https://www.raywenderlich.com/97886/instruments-tutorial-with-swift-getting-started" target="_blank" rel="noopener">link1</a>, <a href="https://blog.leancloud.cn/2835/" target="_blank" rel="noopener">link2</a></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.zhihu.com/question/29023547/answer/109570584" target="_blank" rel="noopener">1.iOS开发中，block与代理的对比，双方的优缺点及在什么样的环境下，优先使用哪一种更为合适？</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jichaowu.com/2016/07/19/iOS_memory_leak/" data-id="cjh5yh7dc0001olre8xguqppj" class="article-share-link">Share</a><div class="tags"></div><div class="post-nav"><a href="/2017/07/25/remote_debug/" class="pre">小程序真机调试探索</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jichaowu.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/annotation/">Spring常用注解整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/25/remote_debug/">小程序真机调试探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/iOS_memory_leak/">iOS 内存泄露问题实践</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Jichao's Tech Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>